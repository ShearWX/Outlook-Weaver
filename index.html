<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SPC Outlook Generator</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #eef2f5;
            margin: 0;
            padding: 0;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* Sidebar Styling */
        .sidebar {
            width: 260px;
            background-color: #2c3e50;
            color: white;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            box-shadow: 2px 0 10px rgba(0,0,0,0.2);
            overflow-y: auto;
            flex-shrink: 0;
        }

        .sidebar h2 {
            margin-top: 0;
            font-size: 1.2rem;
            border-bottom: 1px solid #4a6278;
            padding-bottom: 10px;
            margin-bottom: 5px;
        }

        .section-title {
            font-size: 0.85rem;
            text-transform: uppercase;
            color: #bdc3c7;
            margin-top: 10px;
            margin-bottom: 5px;
            font-weight: bold;
        }

        /* Button Styling */
        button {
            padding: 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
            text-align: left;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        button:hover {
            opacity: 0.9;
            transform: translateX(2px);
        }

        /* Risk Buttons */
        .risk-btn { margin-bottom: 5px; color: #333; position: relative; }
        .risk-btn.active { ring: 2px solid white; box-shadow: 0 0 0 2px white; transform: scale(1.02); z-index: 10; }
        
        .btn-tstm { background-color: #c1e9c1; color: #1a3d1a; }
        .btn-mrgl { background-color: #76c043; color: white; text-shadow: 0 1px 1px rgba(0,0,0,0.3); }
        .btn-slgt { background-color: #ffeb3b; color: #333; }
        .btn-enh  { background-color: #e69f00; color: white; text-shadow: 0 1px 1px rgba(0,0,0,0.3); }
        .btn-mdt  { background-color: #e60000; color: white; text-shadow: 0 1px 1px rgba(0,0,0,0.3); }
        .btn-high { background-color: #ff00ff; color: white; text-shadow: 0 1px 1px rgba(0,0,0,0.3); }

        /* Tool Buttons */
        .tool-btn {
            background-color: #34495e;
            color: #ecf0f1;
            margin-bottom: 5px;
            justify-content: center;
        }
        .tool-btn:hover { background-color: #46607a; }
        
        .tool-btn.active-tool {
            background-color: #3498db;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.2);
        }

        .action-btn {
            background-color: #27ae60;
            color: white;
            justify-content: center;
            margin-top: 5px;
        }
        
        .file-input { display: none; }

        /* Main Area */
        .main-content {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            background-color: #95a5a6; /* Neutral background behind canvas */
            padding: 20px;
        }

        #canvas-wrapper {
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
            border: 4px solid #fff;
            background-color: white;
            overflow: hidden;
            max-width: 100%;
            max-height: 100%;
            display: flex;
        }

        canvas {
            display: block;
            cursor: crosshair;
        }
        
        canvas.edit-mode {
            cursor: default;
        }

        .status-bar {
            position: absolute;
            bottom: 0;
            width: 100%;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            text-align: center;
            font-size: 0.9rem;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div class="sidebar">
        <h2>SPC Outlook Tool</h2>
        
        <div class="section-title">Risk Categories</div>
        <button class="risk-btn btn-tstm" onclick="setMode('draw'); setRisk('TSTM', '#c1e9c1', 0)"><span>GEN TSTM</span> <span>0</span></button>
        <button class="risk-btn btn-mrgl" onclick="setMode('draw'); setRisk('MRGL', '#76c043', 1)"><span>1-MRGL</span> <span>1</span></button>
        <button class="risk-btn btn-slgt" onclick="setMode('draw'); setRisk('SLGT', '#ffeb3b', 2)"><span>2-SLGT</span> <span>2</span></button>
        <button class="risk-btn btn-enh"  onclick="setMode('draw'); setRisk('ENH',  '#e69f00', 3)"><span>3-ENH</span> <span>3</span></button>
        <button class="risk-btn btn-mdt"  onclick="setMode('draw'); setRisk('MDT',  '#e60000', 4)"><span>4-MDT</span> <span>4</span></button>
        <button class="risk-btn btn-high" onclick="setMode('draw'); setRisk('HIGH', '#ff00ff', 5)"><span>5-HIGH</span> <span>5</span></button>

        <div class="section-title">Tools</div>
        <button class="tool-btn" id="btn-edit" onclick="toggleEditMode()">üîß Edit Polygons</button>
        <button class="tool-btn" onclick="undoLastPoint()">‚Ü© Undo Point</button>
        <button class="tool-btn" onclick="undoLastShape()">üîô Undo Shape</button>
        <button class="tool-btn" style="background-color: #c0392b;" onclick="clearAll()">üóëÔ∏è Clear All</button>

        <div class="section-title">File</div>
        <button class="tool-btn" onclick="document.getElementById('mapUpload').click()">üìÇ Upload Map</button>
        <input type="file" id="mapUpload" class="file-input" accept="image/*" onchange="handleImageUpload(this)">
        <button class="action-btn" onclick="downloadImage()">üíæ Save Image</button>
    </div>

    <div class="main-content">
        <div id="canvas-wrapper">
            <canvas id="outlookCanvas"></canvas>
        </div>
        <div class="status-bar" id="status-text">Ready</div>
    </div>

    <script>
        // --- Configuration ---
        const canvas = document.getElementById('outlookCanvas');
        const ctx = canvas.getContext('2d');
        const statusText = document.getElementById('status-text');
        
        // Translucent fill for the risk areas
        const FILL_OPACITY = 0.5; 
        const STROKE_WIDTH = 2; 
        const HANDLE_RADIUS = 6;
        const LABEL_HANDLE_RADIUS = 4; // Smaller handle for label positioning
        
        // --- State ---
        let appState = {
            mode: 'draw', // 'draw' or 'edit'
            backgroundImage: new Image(),
            // Shapes now include labelOffset: {x, y}
            shapes: [], 
            currentPoints: [],
            currentRisk: { type: 'SLGT', color: '#ffeb3b', priority: 2 },
            // Added isLabelDrag to drag state
            drag: { isDragging: false, shapeIndex: -1, pointIndex: -1, isLabelDrag: false }
        };

        // --- Initialization ---
        window.onload = function() {
            // Base image data is embedded here to ensure instant loading.
            const embeddedImageSrc = 'uploaded:day1otlk_0100.jpeg-04a26644-706f-4ae2-836f-33b20590ae80';
            appState.backgroundImage.src = embeddedImageSrc;
            
            appState.backgroundImage.onload = function() {
                resizeCanvasToImage();
                draw();
                updateStatus("Base map loaded instantly. Select a risk to draw.");
            };
            
            // Select default risk UI
            highlightRiskBtn('SLGT');
        };

        // --- Core Functions ---

        function resizeCanvasToImage() {
            if (appState.backgroundImage.complete && appState.backgroundImage.naturalWidth > 0) {
                // Let's keep original resolution for quality, CSS handles display size
                canvas.width = appState.backgroundImage.naturalWidth;
                canvas.height = appState.backgroundImage.naturalHeight;
            }
        }

        function setRisk(type, color, priority) {
            appState.currentRisk = { type, color, priority };
            highlightRiskBtn(type);
            updateStatus(`Drawing Risk: ${type}`);
            
            setMode('draw'); 
        }

        function setMode(mode) {
            appState.mode = mode;
            
            if (mode === 'edit') {
                canvas.classList.add('edit-mode');
                document.getElementById('btn-edit').classList.add('active-tool');
                // clear current drawing if any
                appState.currentPoints = [];
                updateStatus("Edit Mode: Drag white handles to move points or blue handles to move labels.");
            } else {
                canvas.classList.remove('edit-mode');
                document.getElementById('btn-edit').classList.remove('active-tool');
                updateStatus(`Draw Mode: ${appState.currentRisk.type}`);
            }
            draw();
        }

        function toggleEditMode() {
            setMode(appState.mode === 'edit' ? 'draw' : 'edit');
        }

        // --- Drawing Helpers ---
        
        function getCentroid(points) {
            if (points.length === 0) return { x: 0, y: 0 };
            let cx = 0, cy = 0;
            points.forEach(p => { cx += p.x; cy += p.y; });
            cx /= points.length;
            cy /= points.length;
            return { x: cx, y: cy };
        }

        // Creates a path for a single polygon
        function drawPolygonPath(pts) {
            if (pts.length < 2) return;
            ctx.beginPath();
            ctx.moveTo(pts[0].x, pts[0].y);
            for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
            ctx.closePath();
        }
        
        // Draws a single label for a shape
        function drawIndividualLabel(shape) {
            const centroid = getCentroid(shape.points);
            const type = shape.type;
            
            // Apply offset if available
            const offsetX = shape.labelOffset ? shape.labelOffset.x : 0;
            const offsetY = shape.labelOffset ? shape.labelOffset.y : 0;
            const x = centroid.x + offsetX;
            const y = centroid.y + offsetY;
            
            ctx.font = "bold 14px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            
            // Shadow for readability
            ctx.fillStyle = "rgba(0,0,0,0.7)"; 
            ctx.fillText(type, x + 1, y + 1);
            
            ctx.fillStyle = "white";
            ctx.fillText(type, x, y);
        }

        function draw(mouseX, mouseY) {
            // 1. Clear
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 2. Background
            if (appState.backgroundImage.complete && appState.backgroundImage.naturalWidth > 0) {
                ctx.drawImage(appState.backgroundImage, 0, 0);
            } else {
                ctx.fillStyle = '#fff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.textAlign = "center";
                ctx.fillStyle = '#ccc';
                ctx.fillText("Map failed to load. Please use 'Upload Map'.", canvas.width/2, canvas.height/2);
            }

            // 3. Sort Shapes by Priority (Low -> High)
            const sortedShapes = [...appState.shapes].sort((a, b) => a.priority - b.priority);

            // 4. Drawing Pass 1: Fill and Cutout (Priority Low -> High)
            sortedShapes.forEach(shape => {
                const pts = shape.points;

                // --- 4a. Masking (Cut out lower risks beneath this shape) ---
                ctx.save(); 
                ctx.globalCompositeOperation = 'destination-out';
                
                drawPolygonPath(pts); 
                
                // 1. Cutout the fill area
                ctx.fillStyle = 'black';
                ctx.fill();
                
                // 2. Cutout the stroke area as well. Use a slightly wider stroke (STROKE_WIDTH * 1.5) 
                // to ensure the lower-priority shape's existing outline is sufficiently erased.
                ctx.lineWidth = STROKE_WIDTH * 1.5; 
                ctx.strokeStyle = 'black'; // Color doesn't matter for destination-out
                ctx.stroke();
                
                ctx.restore(); 

                // --- 4b. Draw the actual shape (Fill only, using lower opacity) ---
                drawPolygonPath(pts); 
                ctx.fillStyle = hexToRgba(shape.color, FILL_OPACITY); 
                ctx.fill();
            });

            // 5. Drawing Pass 2: Strokes and Labels (Per-Shape Drawing - no combining)
            const OUTLINE_COLOR = '#888888'; // Lighter, neutral grey color
            
            sortedShapes.forEach(shape => {
                const pts = shape.points;

                // --- 5a. Draw Stroke ---
                drawPolygonPath(pts);
                ctx.lineWidth = STROKE_WIDTH; // Now 2px
                ctx.strokeStyle = OUTLINE_COLOR; // Outline uses new grey color
                ctx.stroke();

                // --- 5b. Draw Arrow Head (now using OUTLINE_COLOR) ---
                if (pts.length >= 3) {
                    drawArrowOnPolygon(pts, OUTLINE_COLOR); // Arrow uses new grey color
                }

                // --- 5c. Draw Label (Non-consolidated) ---
                drawIndividualLabel(shape);
            });


            // 6. Edit Handles (Drawn over everything, only in edit mode)
            if (appState.mode === 'edit') {
                appState.shapes.forEach((shape) => {
                    // Draw vertex handles (white circles)
                    ctx.fillStyle = 'white';
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 1;
                    shape.points.forEach(p => {
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, HANDLE_RADIUS, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                    });

                    // Draw label offset handle (blue circle)
                    const centroid = getCentroid(shape.points);
                    const labelX = centroid.x + shape.labelOffset.x;
                    const labelY = centroid.y + shape.labelOffset.y;
                    
                    ctx.fillStyle = '#3498db'; // Blue for label handle
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 1;

                    ctx.beginPath();
                    ctx.arc(labelX, labelY, LABEL_HANDLE_RADIUS, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    
                    // Draw a thin line from centroid to label handle for context
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.setLineDash([2, 2]);
                    ctx.beginPath();
                    ctx.moveTo(centroid.x, centroid.y);
                    ctx.lineTo(labelX, labelY);
                    ctx.stroke();
                    ctx.setLineDash([]);
                });
            }

            // 7. Render Current Drawing
            if (appState.currentPoints.length > 0) {
                drawCurrentPath(mouseX, mouseY);
            }
        }
        
        // Draws an arrow head using the specified color
        function drawArrowOnPolygon(points, color) { 
            if (points.length < 3) return; 
            const last = points[points.length - 1];
            const prev = points[points.length - 2]; 
            drawArrowHead(prev.x, prev.y, last.x, last.y, color); 
        }

        // Draws an arrow head using the specified color
        function drawArrowHead(fromX, fromY, toX, toY, color) { 
            const headLength = 15; // length of head in pixels
            const angle = Math.atan2(toY - fromY, toX - fromX);

            ctx.beginPath();
            ctx.moveTo(toX, toY);
            ctx.lineTo(toX - headLength * Math.cos(angle - Math.PI / 6), toY - headLength * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(toX - headLength * Math.cos(angle + Math.PI / 6), toY - headLength * Math.sin(angle + Math.PI / 6));
            ctx.lineTo(toX, toY);
            ctx.fillStyle = color; 
            ctx.fill();
        }

        function drawCurrentPath(mouseX, mouseY) {
            ctx.beginPath();
            ctx.moveTo(appState.currentPoints[0].x, appState.currentPoints[0].y);
            for (let i = 1; i < appState.currentPoints.length; i++) {
                ctx.lineTo(appState.currentPoints[i].x, appState.currentPoints[i].y);
            }
            if (mouseX !== undefined) {
                ctx.lineTo(mouseX, mouseY);
            }
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]); // Dashed line for preview
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw vertices
            ctx.fillStyle = appState.currentRisk.color;
            appState.currentPoints.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // --- Interaction Handlers ---

        canvas.addEventListener('mousedown', (e) => {
            const { x, y } = getMousePos(e);

            // Edit Mode Logic
            if (appState.mode === 'edit') {
                
                // 1. Check for Label Handle Click (Check top shapes first)
                for (let i = appState.shapes.length - 1; i >= 0; i--) {
                    const shape = appState.shapes[i];
                    const centroid = getCentroid(shape.points);
                    const labelX = centroid.x + shape.labelOffset.x;
                    const labelY = centroid.y + shape.labelOffset.y;
                    
                    const dist = Math.hypot(labelX - x, labelY - y);
                    if (dist <= LABEL_HANDLE_RADIUS + 2) {
                        appState.drag.isDragging = true;
                        appState.drag.isLabelDrag = true; 
                        appState.drag.shapeIndex = i;
                        return;
                    }
                }

                // 2. Check if clicking a Polygon Vertex Handle
                for (let i = appState.shapes.length - 1; i >= 0; i--) { 
                    const shape = appState.shapes[i];
                    for (let j = 0; j < shape.points.length; j++) {
                        const p = shape.points[j];
                        const dist = Math.hypot(p.x - x, p.y - y);
                        if (dist <= HANDLE_RADIUS + 2) {
                            appState.drag.isDragging = true;
                            appState.drag.isLabelDrag = false; 
                            appState.drag.shapeIndex = i;
                            appState.drag.pointIndex = j;
                            return;
                        }
                    }
                }
                return;
            }

            // Draw Mode Logic
            if (e.button === 2) { // Right click
                finishShape();
                return;
            }
            appState.currentPoints.push({ x, y });
            draw();
        });

        canvas.addEventListener('mousemove', (e) => {
            const { x, y } = getMousePos(e);

            if (appState.mode === 'edit' && appState.drag.isDragging) {
                const sIdx = appState.drag.shapeIndex;
                if (sIdx > -1) {
                    if (appState.drag.isLabelDrag) {
                        // Move Label Logic
                        const shape = appState.shapes[sIdx];
                        const centroid = getCentroid(shape.points);
                        
                        // Calculate new offset relative to the centroid
                        shape.labelOffset.x = x - centroid.x;
                        shape.labelOffset.y = y - centroid.y;

                    } else {
                        // Move Polygon Vertex Logic
                        const pIdx = appState.drag.pointIndex;
                        if (pIdx > -1) {
                            appState.shapes[sIdx].points[pIdx] = { x, y };
                        }
                    }
                    draw();
                }
            } else if (appState.mode === 'draw') {
                draw(x, y);
            }
        });

        canvas.addEventListener('mouseup', () => {
            if (appState.mode === 'edit') {
                appState.drag.isDragging = false;
                appState.drag.shapeIndex = -1;
                appState.drag.pointIndex = -1;
                appState.drag.isLabelDrag = false; // Reset label drag flag
            }
        });

        canvas.addEventListener('dblclick', (e) => {
            e.preventDefault();
            if (appState.mode === 'draw') finishShape();
        });

        canvas.addEventListener('contextmenu', e => e.preventDefault());

        function getMousePos(evt) {
            const rect = canvas.getBoundingClientRect();
            // Scale in case canvas is displayed smaller than actual resolution
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: (evt.clientX - rect.left) * scaleX,
                y: (evt.clientY - rect.top) * scaleY
            };
        }

        function finishShape() {
            if (appState.currentPoints.length < 3) {
                appState.currentPoints = []; // cancel
                draw();
                return;
            }

            // Add new shape
            appState.shapes.push({
                type: appState.currentRisk.type,
                color: appState.currentRisk.color,
                priority: appState.currentRisk.priority,
                points: [...appState.currentPoints],
                labelOffset: { x: 0, y: 0 } // Initialize label offset for new shapes
            });
            appState.currentPoints = [];
            draw();
        }

        // --- Tool Actions ---

        function undoLastPoint() {
            if (appState.mode === 'draw' && appState.currentPoints.length > 0) {
                appState.currentPoints.pop();
                draw();
            }
        }

        function undoLastShape() {
            if (appState.shapes.length > 0) {
                appState.shapes.pop();
                draw();
            }
        }

        function clearAll() {
            appState.shapes = [];
            appState.currentPoints = [];
            draw();
            updateStatus("All polygons cleared.");
        }

        function handleImageUpload(input) {
            if (input.files && input.files[0]) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    appState.backgroundImage.src = e.target.result;
                    // Onload handler will trigger resize
                }
                reader.readAsDataURL(input.files[0]);
            }
        }

        function downloadImage() {
            // Temporarily hide handles if in edit mode
            const prevMode = appState.mode;
            appState.mode = 'preview'; // dummy mode to hide handles
            draw();
            
            const link = document.createElement('a');
            link.download = 'spc_outlook_forecast.png';
            link.href = canvas.toDataURL();
            link.click();
            
            // Restore
            appState.mode = prevMode;
            draw();
        }

        // --- Helpers ---

        function highlightRiskBtn(type) {
            document.querySelectorAll('.risk-btn').forEach(b => b.classList.remove('active'));
            const map = {
                'TSTM': '.btn-tstm', 'MRGL': '.btn-mrgl', 'SLGT': '.btn-slgt',
                'ENH': '.btn-enh', 'MDT': '.btn-mdt', 'HIGH': '.btn-high'
            };
            const sel = document.querySelector(map[type]);
            if (sel) sel.classList.add('active');
        }

        function updateStatus(msg) {
            statusText.textContent = msg;
        }

        function hexToRgba(hex, alpha) {
            let r = 0, g = 0, b = 0;
            if (hex.length == 4) {
                r = parseInt("0x" + hex[1] + hex[1]);
                g = parseInt("0x" + hex[2] + hex[2]);
                b = parseInt("0x" + hex[3] + hex[3]);
            } else if (hex.length == 7) {
                r = parseInt("0x" + hex[1] + hex[2]);
                g = parseInt("0x" + hex[3] + hex[4]);
                b = parseInt("0x" + hex[5] + hex[6]);
            }
            return `rgba(${r},${g},${b},${alpha})`;
        }
    </script>
</body>
</html>
