<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SPC Outlook Generator</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #eef2f5;
            margin: 0;
            padding: 0;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* Sidebar Styling */
        .sidebar {
            width: 260px;
            background-color: #2c3e50;
            color: white;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            box-shadow: 2px 0 10px rgba(0,0,0,0.2);
            overflow-y: auto;
            flex-shrink: 0;
        }

        .sidebar h2 {
            margin-top: 0;
            font-size: 1.2rem;
            border-bottom: 1px solid #4a6278;
            padding-bottom: 10px;
            margin-bottom: 5px;
        }

        .section-title {
            font-size: 0.85rem;
            text-transform: uppercase;
            color: #bdc3c7;
            margin-top: 10px;
            margin-bottom: 5px;
            font-weight: bold;
        }

        /* Button Styling */
        button {
            padding: 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
            text-align: left;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        button:hover {
            opacity: 0.9;
            transform: translateX(2px);
        }

        /* Risk Buttons */
        .risk-btn { margin-bottom: 5px; color: #333; position: relative; }
        .risk-btn.active { ring: 2px solid white; box-shadow: 0 0 0 2px white; transform: scale(1.02); z-index: 10; }
        
        .btn-tstm { background-color: #c1e9c1; color: #1a3d1a; }
        .btn-mrgl { background-color: #76c043; color: white; text-shadow: 0 1px 1px rgba(0,0,0,0.3); }
        .btn-slgt { background-color: #ffeb3b; color: #333; }
        .btn-enh  { background-color: #e69f00; color: white; text-shadow: 0 1px 1px rgba(0,0,0,0.3); }
        .btn-mdt  { background-color: #e60000; color: white; text-shadow: 0 1px 1px rgba(0,0,0,0.3); }
        .btn-high { background-color: #ff00ff; color: white; text-shadow: 0 1px 1px rgba(0,0,0,0.3); }

        /* Tool Buttons */
        .tool-btn {
            background-color: #34495e;
            color: #ecf0f1;
            margin-bottom: 5px;
            justify-content: center;
        }
        .tool-btn:hover { background-color: #46607a; }
        
        .tool-btn.active-tool {
            background-color: #3498db;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.2);
        }
        
        /* New class for the white toggle button */
        .tool-btn.active-tool-white {
            background-color: white; 
            color: #2c3e50; /* Dark text on white background */
            box-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        }

        .action-btn {
            background-color: #27ae60;
            color: white;
            justify-content: center;
            margin-top: 5px;
        }
        
        .file-input { display: none; }

        /* Main Area */
        .main-content {
            flex-grow = 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            background-color: #95a5a6; /* Neutral background behind canvas */
            padding: 20px;
        }

        #canvas-wrapper {
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
            border: 4px solid #fff;
            background-color: white;
            overflow: hidden;
            max-width: 100%;
            max-height: 100%;
            display: flex;
        }

        canvas {
            display: block;
            cursor: crosshair;
        }
        
        canvas.edit-mode {
            cursor: default;
        }

        .status-bar {
            position: absolute;
            bottom: 0;
            width: 100%;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            text-align: center;
            font-size: 0.9rem;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div class="sidebar">
        <h2>SPC Outlook Tool</h2>
        
        <div class="section-title">Risk Categories</div>
        <button class="risk-btn btn-tstm" onclick="setMode('draw'); setRisk('TSTM', '#c1e9c1', 0)"><span>GEN TSTM</span> <span>0</span></button>
        <button class="risk-btn btn-mrgl" onclick="setMode('draw'); setRisk('MRGL', '#76c043', 1)"><span>1-MRGL</span> <span>1</span></button>
        <button class="risk-btn btn-slgt" onclick="setMode('draw'); setRisk('SLGT', '#ffeb3b', 2)"><span>2-SLGT</span> <span>2</span></button>
        <button class="risk-btn btn-enh"  onclick="setMode('draw'); setRisk('ENH',  '#e69f00', 3)"><span>3-ENH</span> <span>3</span></button>
        <button class="risk-btn btn-mdt"  onclick="setMode('draw'); setRisk('MDT',  '#e60000', 4)"><span>4-MDT</span> <span>4</span></button>
        <button class="risk-btn btn-high" onclick="setMode('draw'); setRisk('HIGH', '#ff00ff', 5)"><span>5-HIGH</span> <span>5</span></button>

        <div class="section-title">Tools</div>
        <button class="tool-btn" id="btn-auto-buffer" onclick="toggleAutoBuffer()">üîó Auto-Buffer (OFF)</button>
        <button class="tool-btn" id="btn-edit" onclick="toggleEditMode()">üîß Edit Polygons</button>
        <button class="tool-btn" onclick="undoLastPoint()">‚Ü© Undo Point</button>
        <button class="tool-btn" onclick="undoLastShape()">üîô Undo Shape</button>
        <button class="tool-btn" style="background-color: #c0392b;" onclick="clearAll()">üóëÔ∏è Clear All</button>

        <div class="section-title">File</div>
        <button class="tool-btn" onclick="document.getElementById('mapUpload').click()">üìÇ Upload Map</button>
        <input type="file" id="mapUpload" class="file-input" accept="image/*" onchange="handleImageUpload(this)">
        <button class="action-btn" onclick="downloadImage()">üíæ Save Image</button>
    </div>

    <div class="main-content">
        <div id="canvas-wrapper">
            <canvas id="outlookCanvas"></canvas>
        </div>
        <div class="status-bar" id="status-text">Ready</div>
    </div>

    <script>
        // --- Configuration ---
        const canvas = document.getElementById('outlookCanvas');
        const ctx = canvas.getContext('2d');
        const statusText = document.getElementById('status-text');
        
        const STROKE_WIDTH = 2; 
        const HANDLE_RADIUS = 6;
        const LABEL_HANDLE_RADIUS = 4;
        const HIGHLIGHT_COLOR = '#3498db'; // Bright blue for selected points
        
        // NEW CONSTANTS for edge clicking tolerance
        const EDGE_TOLERANCE = 10;
        const EDGE_TOLERANCE_SQ = EDGE_TOLERANCE * EDGE_TOLERANCE;
        
        // Configuration for all risk levels
        const ALL_RISKS_CONFIG = [
            { type: 'HIGH', priority: 5, color: '#ff00ff', darkColor: '#a800a8', btnClass: 'btn-high' },
            { type: 'MDT',  priority: 4, color: '#e60000', darkColor: '#990000', btnClass: 'btn-mdt' },
            { type: 'ENH',  priority: 3, color: '#e69f00', darkColor: '#996600', btnClass: 'btn-enh' },
            { type: 'SLGT', priority: 2, color: '#ffeb3b', darkColor: '#a87800', btnClass: 'btn-slgt' },
            { type: 'MRGL', priority: 1, color: '#76c043', darkColor: '#447027', btnClass: 'btn-mrgl' },
            { type: 'TSTM', priority: 0, color: '#c1e9c1', darkColor: '#1a3d1a', btnClass: 'btn-tstm' }
        ];

        // Lookup map for easy access
        const RISK_LOOKUP = {};
        ALL_RISKS_CONFIG.forEach(r => {
            RISK_LOOKUP[r.type] = r;
        });

        // Increased buffer size step (15% per priority level down)
        const SCALE_INCREMENT = 0.15; 
        
        // --- Off-Screen Risk Layer Setup ---
        const riskCanvas = document.createElement('canvas');
        const riskCtx = riskCanvas.getContext('2d');
        
        // --- State ---
        let appState = {
            mode: 'draw', 
            backgroundImage: new Image(),
            shapes: [], 
            currentPoints: [],
            currentRisk: RISK_LOOKUP['SLGT'],
            drag: { isDragging: false, shapeIndex: -1, pointIndex: -1, isLabelDrag: false },
            isAutoBufferEnabled: false, // DEFAULT IS OFF
            selectedShapeIndex: -1 // New state for exclusive editing
        };

        // --- Initialization ---
        window.onload = function() {
            // Placeholder map URL (US Map)
            const embeddedImageSrc = 'https://www.spc.noaa.gov/products/outlook/day1otlk_0100.gif';
            
            appState.backgroundImage.crossOrigin = "Anonymous";
            appState.backgroundImage.src = embeddedImageSrc;
            
            appState.backgroundImage.onload = function() {
                resizeCanvasToImage();
                draw();
                updateStatus("Base map loaded. Select a risk to draw.");
            };

            appState.backgroundImage.onerror = function() {
                 updateStatus("Default map failed to load. Please use 'Upload Map'.");
                 // Set a default size so the canvas isn't 0x0
                 canvas.width = 800;
                 canvas.height = 600;
                 riskCanvas.width = 800;
                 riskCanvas.height = 600;
                 draw();
            };
            
            highlightRiskBtn('SLGT');
            updateAutoBufferButton(); 
        };

        // --- Core Functions ---

        function resizeCanvasToImage() {
            if (appState.backgroundImage.complete && appState.backgroundImage.naturalWidth > 0) {
                canvas.width = appState.backgroundImage.naturalWidth;
                canvas.height = appState.backgroundImage.naturalHeight;
                riskCanvas.width = canvas.width;
                riskCanvas.height = canvas.height;
            }
        }

        function setRisk(type, color, priority) {
            // Set currentRisk using the centralized config lookup
            appState.currentRisk = RISK_LOOKUP[type];
            highlightRiskBtn(type);
            updateStatus(`Drawing Risk: ${type}`);
            setMode('draw'); 
        }

        function setMode(mode) {
            // Deselect any polygon when changing mode
            if (mode !== 'edit') {
                 deselectShape();
            }
            appState.mode = mode;
            
            if (mode === 'edit') {
                canvas.classList.add('edit-mode');
                document.getElementById('btn-edit').classList.add('active-tool');
                appState.currentPoints = [];
                updateStatus("Edit Mode: Click a polygon to select it for editing.");
            } else {
                canvas.classList.remove('edit-mode');
                document.getElementById('btn-edit').classList.remove('active-tool');
                updateStatus(`Draw Mode: ${appState.currentRisk.type}`);
            }
            draw();
        }
        
        function toggleAutoBuffer() {
            appState.isAutoBufferEnabled = !appState.isAutoBufferEnabled;
            updateAutoBufferButton();
            const status = appState.isAutoBufferEnabled ? 'ON' : 'OFF';
            updateStatus(`Auto-Buffer set to ${status}.`);
        }
        
        function updateAutoBufferButton() {
            const btn = document.getElementById('btn-auto-buffer');
            if (appState.isAutoBufferEnabled) {
                btn.classList.add('active-tool-white');
                btn.textContent = 'üîó Auto-Buffer (ON)';
            } else {
                btn.classList.remove('active-tool-white');
                btn.textContent = 'üîó Auto-Buffer (OFF)';
            }
        }

        function toggleEditMode() {
            setMode(appState.mode === 'edit' ? 'draw' : 'edit');
        }
        
        function deselectShape() {
            appState.selectedShapeIndex = -1;
            appState.drag.isDragging = false;
            appState.drag.shapeIndex = -1;
            appState.drag.pointIndex = -1;
            appState.drag.isLabelDrag = false; 
            updateStatus("Edit Mode: Polygon deselected. Click a polygon to select it for editing.");
            draw();
        }

        // --- Geometry Helpers for Edge Insertion ---
        
        // Squared distance between two points
        function distSq(p1, p2) {
            return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);
        }

        // Squared distance from point p to line segment (a, b)
        // From: https://stackoverflow.com/a/6853926/894903
        function distToSegmentSq(p, a, b) {
            const l2 = distSq(a, b);
            if (l2 === 0) return distSq(p, a); // a and b are the same point

            // Consider the vector from a to p, and the vector from a to b.
            // t = projection of ap onto ab, scaled by the length squared of ab
            let t = ((p.x - a.x) * (b.x - a.x) + (p.y - a.y) * (b.y - a.y)) / l2;
            
            // t must be between 0 and 1 (inclusive) to ensure the point is on the segment
            t = Math.max(0, Math.min(1, t)); 
            
            const projection = {
                x: a.x + t * (b.x - a.x),
                y: a.y + t * (b.y - a.y)
            };
            
            return distSq(p, projection);
        }
        
        /**
         * Checks if a point (x, y) is near any edge of the given shape and inserts a new point if true.
         * @returns {number} The index of the newly inserted point, or -1 if no edge was hit.
         */
        function insertPointIfNearEdge(shape, x, y) {
            const points = shape.points;
            if (points.length < 2) return -1;
            
            const clickPoint = { x, y };
            let bestSegmentIndex = -1;

            // Iterate through all segments (p[i] to p[i+1] and p[last] to p[0])
            for (let i = 0; i < points.length; i++) {
                const p1 = points[i];
                // Use the next point, wrapping around to the start point for the closing segment
                const p2 = points[(i + 1) % points.length]; 
                
                const distSq = distToSegmentSq(clickPoint, p1, p2);
                
                if (distSq <= EDGE_TOLERANCE_SQ) {
                    // Hit found! We insert the point right after p1 (index i + 1)
                    bestSegmentIndex = i;
                    break;
                }
            }
            
            if (bestSegmentIndex !== -1) {
                const newIndex = bestSegmentIndex + 1;
                // Insert the new point at the calculated location
                points.splice(newIndex, 0, clickPoint);
                return newIndex;
            }

            return -1;
        }


        // --- Drawing Helpers ---
        
        function getCentroid(points) {
            if (points.length === 0) return { x: 0, y: 0 };
            let cx = 0, cy = 0;
            points.forEach(p => { cx += p.x; cy += p.y; });
            cx /= points.length;
            cy /= points.length;
            return { x: cx, y: cy };
        }

        /**
         * Scales a polygon outwards from its centroid by a given factor.
         */
        function scalePolygon(points, scaleFactor) {
            if (points.length < 3) return [];
            
            const centroid = getCentroid(points);
            const newPoints = [];

            points.forEach(p => {
                const vx = p.x - centroid.x;
                const vy = p.y - centroid.y;

                const newVx = vx * scaleFactor;
                const newVy = vy * scaleFactor;

                newPoints.push({
                    x: centroid.x + newVx,
                    y: centroid.y + newVy
                });
            });

            return newPoints;
        }

        // Creates a path for a single polygon on the given context
        function drawPolygonPath(pts, targetCtx) {
            if (pts.length < 2) return;
            targetCtx.beginPath();
            targetCtx.moveTo(pts[0].x, pts[0].y);
            for (let i = 1; i < pts.length; i++) targetCtx.lineTo(pts[i].x, pts[i].y);
            targetCtx.closePath();
        }
        
        // Draws a single label for a shape on the main context
        function drawIndividualLabel(shape) {
            const centroid = getCentroid(shape.points);
            const type = shape.type;
            
            const offsetX = shape.labelOffset ? shape.labelOffset.x : 0;
            const offsetY = shape.labelOffset ? shape.labelOffset.y : 0;
            const x = centroid.x + offsetX;
            const y = centroid.y + offsetY;
            
            ctx.font = "bold 12px Helvetica, Arial, sans-serif"; 
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            
            // Set font color to the darker outline color
            ctx.fillStyle = shape.darkColor; 
            ctx.fillText(type, x, y);
        }
        
        // Draws an arrow head using the specified color on the given context
        function drawArrowHead(fromX, fromY, toX, toY, color, targetCtx) { 
            const headLength = 10; 
            const angle = Math.atan2(toY - fromY, toX - fromX);
            
            const angle1 = angle + Math.PI / 4; 
            const angle2 = angle - Math.PI / 4; 
            
            const x1 = toX - headLength * Math.cos(angle1);
            const y1 = toY - headLength * Math.sin(angle1);
            
            const x2 = toX - headLength * Math.cos(angle2);
            const y2 = toY - headLength * Math.sin(angle2);
            
            targetCtx.save();
            targetCtx.lineWidth = STROKE_WIDTH; 
            targetCtx.strokeStyle = color;
            targetCtx.lineCap = 'round'; 

            targetCtx.beginPath();
            targetCtx.moveTo(x1, y1);
            targetCtx.lineTo(toX, toY);
            targetCtx.lineTo(x2, y2);
            targetCtx.stroke();
            
            targetCtx.restore();
        }
        
        // Draws the arrow on the polygon stroke
        function drawArrowOnPolygon(points, color, targetCtx) { 
            if (points.length < 3) return; 
            const last = points[points.length - 1];
            const prev = points[points.length - 2]; 
            drawArrowHead(prev.x, prev.y, last.x, last.y, color, targetCtx); 
        }

        // --- Main Drawing Function ---

        function draw(mouseX, mouseY) {
            // 1. Clear Main Canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 2. Draw Background on Main Canvas
            if (appState.backgroundImage.complete && appState.backgroundImage.naturalWidth > 0) {
                ctx.drawImage(appState.backgroundImage, 0, 0);
            } else {
                ctx.fillStyle = '#fff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.textAlign = "center";
                ctx.fillStyle = '#ccc';
                ctx.fillText("Map failed to load. Please use 'Upload Map'.", canvas.width/2, canvas.height/2);
            }
            
            // 3. --- Draw Risk Layers onto the OFF-SCREEN Canvas (riskCtx) ---
            riskCtx.clearRect(0, 0, riskCanvas.width, riskCanvas.height);
            // Sort shapes by priority (0=TSTM lowest, 5=HIGH highest) to ensure lower risks are drawn first
            const sortedShapes = [...appState.shapes].sort((a, b) => a.priority - b.priority);

            sortedShapes.forEach(shape => {
                const pts = shape.points;
                
                // 3a. Masking (Cut out lower risks beneath this shape on the risk layer)
                riskCtx.save(); 
                riskCtx.globalCompositeOperation = 'destination-out';
                
                drawPolygonPath(pts, riskCtx); 
                
                // Cutout the fill area
                riskCtx.fillStyle = 'black';
                riskCtx.fill();
                
                // This makes the transition gap small.
                riskCtx.lineWidth = STROKE_WIDTH; 
                riskCtx.strokeStyle = 'black'; 
                riskCtx.stroke();
                
                riskCtx.restore(); 

                // 3b. Draw the actual shape (Fill and Stroke)
                riskCtx.globalCompositeOperation = 'source-over'; 
                
                // Draw Fill (With Transparency: 0.6)
                drawPolygonPath(pts, riskCtx); 
                riskCtx.fillStyle = shape.color; 
                riskCtx.globalAlpha = 0.6; 
                riskCtx.fill();
                riskCtx.globalAlpha = 1.0; // Reset opacity for stroke
                
                // Draw Stroke (Opaque)
                drawPolygonPath(pts, riskCtx);
                riskCtx.lineWidth = STROKE_WIDTH; 
                // Use the shape's specific dark color for the outline
                riskCtx.strokeStyle = shape.darkColor; 
                riskCtx.stroke();

                // Draw Arrow Head 
                if (pts.length >= 3) {
                    // Use the shape's specific dark color for the arrow
                    drawArrowOnPolygon(pts, shape.darkColor, riskCtx); 
                }
            });

            // 4. Composite Risk Layer onto Main Canvas
            ctx.drawImage(riskCanvas, 0, 0);

            // 5. Background Greying for Exclusive Edit Mode
            if (appState.mode === 'edit' && appState.selectedShapeIndex !== -1) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)'; // 20% transparent black overlay
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }


            // 6. Drawing Pass 3: Labels and Handles (Drawn on Main Canvas)
            
            // 6a. Draw Labels
            sortedShapes.forEach(drawIndividualLabel);

            // 6b. Edit Handles (Only in edit mode)
            if (appState.mode === 'edit') {
                const shapesToDrawHandles = appState.selectedShapeIndex !== -1 
                    ? [appState.shapes[appState.selectedShapeIndex]]
                    : appState.shapes; // If nothing selected, draw handles for all

                shapesToDrawHandles.forEach((shape) => {
                    const isSelected = appState.selectedShapeIndex !== -1 && shape === appState.shapes[appState.selectedShapeIndex];

                    // Draw vertex handles
                    ctx.fillStyle = isSelected ? HIGHLIGHT_COLOR : 'white'; // Blue when selected, white otherwise
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 1;
                    shape.points.forEach(p => {
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, HANDLE_RADIUS, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                    });

                    // Draw label offset handle (always blue)
                    const centroid = getCentroid(shape.points);
                    const labelX = centroid.x + shape.labelOffset.x;
                    const labelY = centroid.y + shape.labelOffset.y;
                    
                    ctx.fillStyle = HIGHLIGHT_COLOR; 
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 1;

                    ctx.beginPath();
                    ctx.arc(labelX, labelY, LABEL_HANDLE_RADIUS, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    
                    // Draw a thin line from centroid to label handle for context
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.setLineDash([2, 2]);
                    ctx.beginPath();
                    ctx.moveTo(centroid.x, centroid.y);
                    ctx.lineTo(labelX, labelY);
                    ctx.stroke();
                    ctx.setLineDash([]);
                });
            }

            // 7. Render Current Drawing
            if (appState.currentPoints.length > 0) {
                drawCurrentPath(mouseX, mouseY);
            }
        }

        // Draws the temporary path when drawing a new polygon
        function drawCurrentPath(mouseX, mouseY) {
            ctx.beginPath();
            ctx.moveTo(appState.currentPoints[0].x, appState.currentPoints[0].y);
            for (let i = 1; i < appState.currentPoints.length; i++) {
                ctx.lineTo(appState.currentPoints[i].x, appState.currentPoints[i].y);
            }
            if (mouseX !== undefined) {
                ctx.lineTo(mouseX, mouseY);
            }
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]); // Dashed line for preview
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw vertices
            ctx.fillStyle = appState.currentRisk.color;
            ctx.globalAlpha = 0.6; // Preview transparency
            appState.currentPoints.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1.0;
        }

        // --- Interaction Handlers ---

        function isPointInHandle(p, x, y) {
            return Math.hypot(p.x - x, p.y - y) <= HANDLE_RADIUS + 2;
        }
        
        function isPointInLabelHandle(shape, x, y) {
            const centroid = getCentroid(shape.points);
            const labelX = centroid.x + shape.labelOffset.x;
            const labelY = centroid.y + shape.labelOffset.y;
            return Math.hypot(labelX - x, labelY - y) <= LABEL_HANDLE_RADIUS + 2;
        }


        canvas.addEventListener('mousedown', (e) => {
            const { x, y } = getMousePos(e);

            // Edit Mode Logic
            if (appState.mode === 'edit') {
                
                // 1. If a shape is ALREADY selected (Exclusive Edit Mode)
                if (appState.selectedShapeIndex !== -1) {
                    const selectedShape = appState.shapes[appState.selectedShapeIndex];
                    
                    // Track if we started dragging anything
                    let dragInitiated = false;

                    // Check label handle of SELECTED shape
                    if (isPointInLabelHandle(selectedShape, x, y)) {
                        appState.drag.isDragging = true;
                        appState.drag.isLabelDrag = true; 
                        appState.drag.shapeIndex = appState.selectedShapeIndex;
                        updateStatus("Editing label position...");
                        dragInitiated = true;
                        return;
                    }
                    
                    // Check vertex handles of SELECTED shape
                    for (let j = 0; j < selectedShape.points.length; j++) {
                        if (isPointInHandle(selectedShape.points[j], x, y)) {
                            appState.drag.isDragging = true;
                            appState.drag.isLabelDrag = false; 
                            appState.drag.shapeIndex = appState.selectedShapeIndex;
                            appState.drag.pointIndex = j;
                            updateStatus("Editing polygon vertex...");
                            dragInitiated = true;
                            return;
                        }
                    }
                    
                    // NEW LOGIC: Check for insertion on edges of the SELECTED shape
                    const insertedIndex = insertPointIfNearEdge(selectedShape, x, y);
                    if (insertedIndex !== -1) {
                        // Start dragging the new point immediately
                        appState.drag.isDragging = true;
                        appState.drag.isLabelDrag = false;
                        appState.drag.shapeIndex = appState.selectedShapeIndex;
                        appState.drag.pointIndex = insertedIndex;
                        updateStatus("New vertex created and selected for editing.");
                        draw();
                        dragInitiated = true;
                        return;
                    }


                    // If click is NOT on any handle or edge, deselect it.
                    if (!dragInitiated) {
                        deselectShape();
                    }
                    return;
                }

                // 2. If NO shape is selected (General Edit Mode)
                
                // Iterate backwards (top layer first) to check for handles/selection
                for (let i = appState.shapes.length - 1; i >= 0; i--) { 
                    const shape = appState.shapes[i];
                    
                    // Check Label Handle
                    if (isPointInLabelHandle(shape, x, y)) {
                        appState.selectedShapeIndex = i;
                        appState.drag.isDragging = true;
                        appState.drag.isLabelDrag = true; 
                        appState.drag.shapeIndex = i;
                        updateStatus(`Selected ${shape.type}. Editing label position...`);
                        draw(); // Redraw for highlight
                        return;
                    }

                    // Check Polygon Vertex Handle
                    for (let j = 0; j < shape.points.length; j++) {
                        if (isPointInHandle(shape.points[j], x, y)) {
                            appState.selectedShapeIndex = i;
                            appState.drag.isDragging = true;
                            appState.drag.isLabelDrag = false; 
                            appState.drag.shapeIndex = i;
                            appState.drag.pointIndex = j;
                            updateStatus(`Selected ${shape.type}. Editing polygon vertex...`);
                            draw(); // Redraw for highlight
                            return;
                        }
                    }
                }
                return;
            }

            // Draw Mode Logic
            if (e.button === 2) { // Right click
                finishShape();
                return;
            }
            appState.currentPoints.push({ x, y });
            draw();
        });

        canvas.addEventListener('mousemove', (e) => {
            const { x, y } = getMousePos(e);

            // Only allow dragging if we are in edit mode AND a shape is actively being dragged
            if (appState.mode === 'edit' && appState.drag.isDragging) {
                const sIdx = appState.drag.shapeIndex;
                if (sIdx > -1) {
                    if (appState.drag.isLabelDrag) {
                        // Move Label Logic
                        const shape = appState.shapes[sIdx];
                        const centroid = getCentroid(shape.points);
                        
                        // Calculate new offset relative to the centroid
                        shape.labelOffset.x = x - centroid.x;
                        shape.labelOffset.y = y - centroid.y;

                    } else {
                        // Move Polygon Vertex Logic
                        const pIdx = appState.drag.pointIndex;
                        if (pIdx > -1) {
                            appState.shapes[sIdx].points[pIdx] = { x, y };
                        }
                    }
                    draw();
                }
            } else if (appState.mode === 'draw') {
                draw(x, y);
            }
        });

        canvas.addEventListener('mouseup', () => {
            if (appState.mode === 'edit') {
                // If a drag operation was in progress, release drag state
                if (appState.drag.isDragging) {
                    // We keep the polygon selected after a vertex move
                    appState.drag.isDragging = false;
                    appState.drag.pointIndex = -1;
                    appState.drag.isLabelDrag = false; 
                    updateStatus(`Selected ${appState.shapes[appState.selectedShapeIndex].type}. Dragging finished. Click on background to save/deselect.`);
                }
            }
        });

        canvas.addEventListener('dblclick', (e) => {
            e.preventDefault();
            if (appState.mode === 'draw') finishShape();
        });

        canvas.addEventListener('contextmenu', e => e.preventDefault());

        function getMousePos(evt) {
            const rect = canvas.getBoundingClientRect();
            // Scale in case canvas is displayed smaller than actual resolution
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: (evt.clientX - rect.left) * scaleX,
                y: (evt.clientY - rect.top) * scaleY
            };
        }

        function finishShape() {
            if (appState.currentPoints.length < 3) {
                appState.currentPoints = []; // cancel
                draw();
                return;
            }

            const currentRisk = appState.currentRisk;
            const originalPoints = [...appState.currentPoints];

            // 1. Create the base shape (the one the user drew)
            const newShape = {
                type: currentRisk.type,
                color: currentRisk.color,
                priority: currentRisk.priority,
                darkColor: currentRisk.darkColor, 
                points: originalPoints,
                labelOffset: { x: 0, y: 0 } 
            };
            appState.shapes.push(newShape);
            
            // 2. Auto-generate lower risks if auto-buffer is enabled and priority > 0
            if (appState.isAutoBufferEnabled && currentRisk.priority > 0) {
                
                // Filter all risks to include only those with lower priority
                const lowerRisks = ALL_RISKS_CONFIG.filter(r => r.priority < currentRisk.priority);
                
                // Sort them from lowest priority (0) to highest priority to maintain correct layering order
                lowerRisks.sort((a, b) => a.priority - b.priority);

                lowerRisks.forEach(riskConfig => {
                    // Calculate scale factor: 1.0 + (difference in priority) * SCALE_INCREMENT
                    const priorityDiff = currentRisk.priority - riskConfig.priority;
                    const scaleFactor = 1.0 + (priorityDiff * SCALE_INCREMENT);

                    // Generate the new, larger set of points
                    const newPoints = scalePolygon(originalPoints, scaleFactor);

                    if (newPoints.length >= 3) {
                        appState.shapes.push({
                            type: riskConfig.type,
                            color: riskConfig.color,
                            priority: riskConfig.priority,
                            darkColor: riskConfig.darkColor,
                            points: newPoints,
                            labelOffset: { x: 0, y: 0 }
                        });
                    }
                });
                
                updateStatus(`Generated ${lowerRisks.length} surrounding outlooks for ${currentRisk.type}!`);
            }


            appState.currentPoints = [];
            // Re-sort all shapes after adding new ones to maintain drawing order (Priority 0 to 5)
            appState.shapes.sort((a, b) => a.priority - b.priority);
            draw();
        }

        // --- Tool Actions ---

        function undoLastPoint() {
            if (appState.mode === 'draw' && appState.currentPoints.length > 0) {
                appState.currentPoints.pop();
                draw();
            }
        }

        function undoLastShape() {
            if (appState.shapes.length > 0) {
                // If a shape is selected, remove it, otherwise remove the last one added.
                if (appState.selectedShapeIndex !== -1) {
                    appState.shapes.splice(appState.selectedShapeIndex, 1);
                    deselectShape();
                    updateStatus("Selected polygon removed.");
                } else {
                    appState.shapes.pop();
                    draw();
                    updateStatus("Last polygon removed.");
                }
            }
        }

        function clearAll() {
            appState.shapes = [];
            appState.currentPoints = [];
            deselectShape(); // Also clears selection
            draw();
            updateStatus("All polygons cleared.");
        }

        function handleImageUpload(input) {
            if (input.files && input.files[0]) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    appState.backgroundImage.src = e.target.result;
                    // Onload handler will trigger resize
                }
                reader.readAsDataURL(input.files[0]);
            }
        }

        function downloadImage() {
            // Temporarily hide handles if in edit mode
            const prevMode = appState.mode;
            const prevSelected = appState.selectedShapeIndex;
            appState.mode = 'preview'; // dummy mode to hide handles
            appState.selectedShapeIndex = -1; // hide greying/handles
            draw();
            
            const link = document.createElement('a');
            link.download = 'spc_outlook_forecast.png';
            link.href = canvas.toDataURL();
            link.click();
            
            // Restore
            appState.mode = prevMode;
            appState.selectedShapeIndex = prevSelected;
            draw();
        }

        // --- Helpers ---

        function highlightRiskBtn(type) {
            document.querySelectorAll('.risk-btn').forEach(b => b.classList.remove('active'));
            const riskConfig = ALL_RISKS_CONFIG.find(r => r.type === type);
            if (riskConfig) {
                const sel = document.querySelector(`.${riskConfig.btnClass}`);
                if (sel) sel.classList.add('active');
            }
        }

        function updateStatus(msg) {
            statusText.textContent = msg;
        }
    </script>
</body>
</html>
